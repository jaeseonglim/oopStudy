# 객체 분해
- 본질적인 정보만 남기고 불필요한 세부 사항을 걸러내어 문제를 단순화 한다.
- 불필요한 정보를 제거하고 현재 문제 해결에 필요한 핵심만 남기는 작업을 `추상화`라고 한다.
- 다뤄야 하는 문제가 크면 한번에 처리할 수 있는 작은 규모의 문제로 나눠 `분해(decomposition)`한다.

## 01. 프로시저 추상화와 데이터 추상화
- 프로그래밍 패러다임은 사용하는 추상화의 종류와 추상화를 이용해 SW를 `분해`하는 방법이 결정된다.
- 시스템 분해하는 방법을 결정하려면 `프로시저 추상화`를 중심으로 할지, `데이터 추상화`를 중심으로 할지 결정해야 한다.
    - `프로시저 추상화` : SW가 **무엇을 해야하는지** 추상화.
    - `데이터 추상화` : SW가 **무엇을 알아야 하는지** 추상화.
    - SW는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.
- 설계 방법에 따라 `프로시저 추상화`나 `데이터 추상화`를 중심으로 시스템을 분해할 수 있다.
    - `프로시저 추상화`를 중심으로 분해한다면 `기능 분해`의 길로 들어서는 것.
    - `데이터 추상화`를 중심으로 분해한다면
        - 데이터 중심으로 `타입 추상화` => 추상 데이터 타입
        - 데이터 중심으로 `프로시저 추상화` => 객체지향
- `협력`하는 공동체를 구성하도록 객체를 나누는 과정은 객체지향 패러다임에서 `분해`를 의미한다.
- `협력`이라는 문맥을 고려하지 않고 객체를 고립시킨채 오퍼레이션이나 타입별로 분배하는것은 올바르지 않다.
- 객체가 참여할 협력을 결정하고 책임을 수행하기 위해 어떤 객체가 필요한지 먼저 고민하고 <br>
해당 책임을 다양한 방식으로 수행해야 할때 시스템 분해를 고려하고 타입 추상화, 오퍼레이션 추가와 같은 수행 방법을 고민하라.
- 일반적인 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법.
    - 이말이 이해안감 앞장 4,5,6장에서는 데이터 중심설계는 객체를 고립시키는 등 책임에 초점을 맞추자고 데이터를 초점 맞추지 말라했는데 갑자기 데이터 중심이라고 하니 헷갈림.

<br>

## 02.프로시저 추상화와 기능 분해
- 프로시저 추상화를 중심으로 기능 분해 관점의 단점을 살펴보자.
<br>

### 메인 함수로서의 시스템
- 기능 분해 관점에서 추상화 단위는 `프로시저`이다.
- 전통적인 기능 분해 방법은 `하향식 접근법`을 통해 기능을 분해해나가는 것.
    - `하향식 접근법` : 시스템을 구성하는 최상위 기능을 정의하고 세부적으로 분해해나가는 방식
- 기능 분해 방법은 기능 중심으로 데이터를 결정해 나간다.

### 급여 관리 시스템 구현
- 기능 분해는 최상위의 가장 추상적인 메인 함수를 정의하고 세부적인 단계로 분해해나간다.
- 직원의 급여를 계산한다는 최상위 기능을 정했다면
    - 사용자로부터 소득세율을 입력받는다.
    - 급여를 계산한다.
    - 양식에 맞는 결과를 출력한다 등으로 분해해 나갈것이다.
    
### 하향식 기능 분해의 문제
- 하향식 기능 분해는 괜찮을 수 있지만 다양한 문제에 직면하게 된다.
    1. 시스템은 최상위 기능이 여러개일 수 있다.
    2. 하위 기능 추가나 요구사항 변경시 상위 기능도 영향을 받을 수 있다.
    3. 비지니스 로직이 사용자 인터페이스와 강결합하게 된다.
    4. 너무 이른시기에 분해가 되기 때문에 실행순서가 고정되어 유연성과 재사용성이 떨어진다.
    5. 데이터 형식이 변경되면 예측이 어렵다.
- `하향식 접근법`과 기능 분해는 변경에 취약한 설계를 낳게 된다.
- 문제점들을 자세히 살펴보자.

#### 1. 하나의 메인 함수라는 비현실적인 아이디어
- 처음에 중요하게 생각했던 최상위 메인 함수는 중요한 여러 함수들 중 하나로 전락할 수 있다.
- 대부분의 시스템에선 하나의 메인 기능이란 개념은 없다.

#### 2. 메인 함수의 빈번한 재설계
- 시스템 내부엔 여러 정상 메서드가 존재하기 때문에 하나의 메인 함수를 유일한 정상으로 설계한 경우 <br>
새로운 기능 추가시 매번 상위 함수를 수정해야한다.
- 위 요구사항에서 모든 직원들의 기본급 총합을 구하는 기능을 추가해달라고 하면 기존엔 개별 직원들 급여 계산하는것을 목적으로 설계했기에 <br>
메인함수에서는 분기처리가 필요해진다.
     
#### 3. 비지니스 로직과 사용자 인터페이스 결합
- `하향식 접근법`은 비지니스 로직을 설계하는 초기 단계부터 비지니스로직과 사용자 인터페이스 로직을 밀접하게 결합시킨다.
- 사용자 인터페이스는 시스탬내에서 자주 변경되고 비지니스 로직은 사용자 인터페이스에 비해 변경 빈도가 낮다.
- `하향식 접근법`을 통해 서로 엮이기 때문에 불안정한 아키텍쳐가 설계가 된다. 
- 사용자로부터 소득세율을 입력받고 급여를 계산한 후 결과를 출력한다. 라는 기능이 존재할경우
    - 급여 계산이라는 비지니스 로직과 계산결과를 출력하는 사용자 인터페이스가 섞여있다.
- 즉, 사용자 인터페이스의 관심사와 비지니스 로직의 관심사를 동시에 고려하도록 강요가 되어 <br>
`관심사의 분리`라는 아키텍쳐의 설계 목적을 달성하기 어렵다.

#### 4. 성급하게 결정된 실행 순서
- `하향식 접근법`으로 분해하는 과정은 하나의 함수를 더 작은 함수로 분해하고 분해된 함수들의 실행 순서를 결정하는 작업이다.
- 설계 시작부터 시스템이 무엇이 아닌 어떻게 동작하는지 집중하게 된다.
    - 직원 급여 계산을 하려면 어떤 작업이 필요할까?
        - 소득세율을 입력받고, 계산하고, 결과를 출력한다.
- **즉 구현을 염두해두고 실행 순서를 정의하게 된다.**
- 구현을 염두하고 진행하기 때문에 중앙집중 제어 스타일로 설계가 되어 중요한 제어흐름은 상위 함수에서 관리하게 된다.
- 재사용도 어렵고 상위 함수와 강하게 결합되어 변경에 취약하게 된다.

#### 5. 데이터 변경으로 인한 파급효과
- 어떤 데이터를 어떤 함수가 사용하는지 추적이 어렵다.
- 데이터 변경시 어떤 함수가 영향이 생기는지 알수가 없다.
- 데이터 변경으로 인한 영향을 최소화 하려면 데이터와 함께 변경되는 부분과 아닌 부분을 분리하여 <br>
함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에 제공되는 오퍼레이션을 통해서만 데이터에 접근하도록 한다.

### 언제 하향식 분해가 유용한가?
- 앞서 하향식 분해의 단점을 강조했지만 유용한 경우도 있다.
- 이미 해결된 알고리즘을 문서화하고 서술하는데 훌륭하다.
- 다만, 커다란 SW를 설계하는데 적합하지 않다.

<br>

## 03. 모듈
### 정보 은닉과 모듈
- 시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현 단위로 묶고, <br>
퍼블릭 인터페이스를 통해서만 접근하도록 하는 것.
- **기능을 기준으로 시스템을 분해하는것이 아니라 변경의 방향에 맞게 시스템을 분해하는 것이다.**
- `정보 은닉` : 시스템을 모듈 단위로 분해하기 위한 기본 원리
    - 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감추는것이 핵심.
    - 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공하여 내부로 함부로 접근을 못하게 하는 것.
- 기능 분해가 하나의 기능을 구현하기 위해 필요한 기능을 탐색하는 과정이라면 모듈 분해는 감줘야 하는 비밀을 보호막을 설치해 보존하는 과정이다.
- 숨겨야할 모듈의 비밀은 무엇인가 ?
    1. 복잡성 : 복잡하면 사용하기 어렵다. 외부에 인터페이스를 제공해 사용하는데 지장없게하여 모듈의 복잡도를 낮춘다.
    2. 변경 가능성 : 외부에 변경가능한 설계가 노출되면 사이드 이펙트가 걷잡을 수 없을 것이다. <br>
        변경 가능한 설계를 모듈 내부로 감추고 외부에는 쉽게 변경되는 인터페이스만 노출한다.
- 자바에서 모듈의 개념은 패키지를 이용할 수 있다.

### 모듈의 장점과 한계
- 모듈의 장점
1. 모듈 내부의 설계가 변경되더라도 모듈 내부에서만 영향을 미친다.
    - 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한이 가능하다.
    - 함수 전체를 분석할 필요가 없이 변경에 대한 이슈를 제어할 수 있다.
2. 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
    - 입출력에 대한 로직은 자연스럽게 모듈 외부로 분리가 된다.
    - 사용자 인터페이스가 추가되더라도 비지니스 로직은 변경되지 않는다.
3. 전역 변수와 전역 함수를 제거하게 되어 네임스페이스 오염을 방지한다.
    - 다른 모듈에서 동일한 이름을 사용할 수 있다. (이름 충돌 완화)
- 모듈은 기능이 아닌 변경의 정도에 따라 시스템을 분해하게 된다.
- 모듈은 외부로부터 감춰야하는 관련성이 높은 데이터와 함수의 집합이다.
    - 높은 응집도
    - 퍼블릭 인터페이스를 통해서만 통신하기에 낮은 결합도

<br>

- 모듈의 단점
    - 인스턴스의 개념을 제공하지 않는다.
    - 좀 더 높은 추상화를 위해 독립적인 단위로 다룰 수 있어야 하는데 이를 만족시키는 개념은 `추상 데이터 타입`이다.

<br>

## 04 데이터 추상화와 추상 데이터 타입
- 타입이란 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수
- 프로시저 추상화로는 프로그램 표현력을 향상시키는데 제한이 있기에 데이터 추상화의 개념이 도입됐다. (리스코프)
    - 추상 객체의 클래스를 정의하는 것으로, 오퍼레이션을 규정해 이용하는 것. 즉, 오퍼레이션을 이용해 추상 데이터 타입을 정의 하는것.
    - 객체 외부에서는 제공하는 오퍼레이션만 관심을 가진다. 객체 내부 관심 x
- `추상 데이터 타입`을 구현하기 위해 필요한 언어의 지원
    - 타입 정의가 가능해야함
    - 타입을 인스턴스로 다루기 위해 오퍼레이션의 정의가 가능해야함
    - 제공된 오퍼레이션만을 통해 조작하도록 데이터를 보호할 수 있어야함
    - 타입에 대해 여러 인스턴스를 생성할 수 있어야함.
- `추상 데이터 타입`은 프로그래밍 언어가 제공하는 타입처럼 사용자 정의 타입을 만들어 시스템의 상태를 저정할 데이터를 표현하는 것.

<br>

## 05 클래스
### 클래스는 추상 데이터 타입인가?
- `추상 데이터 타입`과 클래스는 동일하지 않다.
- `추상 데이터 타입`은 타입을 추상화 한것
    - 오퍼레이션을 기준으로 타입을 묶어 추상화한다.
- 클래스는 절차를 추상화 한것.
    - 타입을 기준으로 오퍼레이션, 절차를 추상화 한다.

### 변경을 기준으로 선택하라
- 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체할 수 있다.
    - 클라이언트가 객체의 타입을 확인한 후 메서드를 호출하는것이 아니라 메시지를 처리할 객체를 찾아 적절한 메서드를 선택한다.
- 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가하는 OOP 특성을 `OCP`라고 한다.  
- 설계는 변경과 관련된 것. 변경에 대한 이유가 타입 추가에 관한것인지, 오퍼레이션 추가에 관한것인지에 따라 추상 데이터 타입 설계, OOP 설계의 방향을 결정할 수 있다.
    - 타입 추가의 변경의 이유가 강하면 OOP적으로 수정
        - 타입 추가는 타입 체크를 일일이 찾아 수정해야하지만 OOP는 새로운 클래스를 상속 계층에 추가하면 된다.
    - 오퍼레이션의 추가의 변경이유가 강하면 추상 데이터 타입쪽으로 수정
        - 오퍼레이션을 추가하면 상속 계층에 모든 클래스에 추가해야 되지만 추상 데이터 타입의 경우 하나의 구현체 내에 포함되어 있기에 상대적으로 간단.
    - 즉, 타입을 빈번하게 추가해야 한다면 OOP 클래스 구조가 유용 <br>
    새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상 데이터 타입을 선택하는것이 유용

<br>

### 협력이 중요하다.
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨채 오퍼레이션이나 타입별로 분배하는것은 올바르지 않다.
- 객체가 참여할 협력을 결정하고 책임을 수행하기 위해 어떤 객체가 필요한지 먼저 고민하고 <br>
해당 책임을 다양한 방식으로 수행해야 할때 시스템 분해를 고려하고 타입 추상화, 오퍼레이션 추가와 같은 수행 방법을 고민하라.
