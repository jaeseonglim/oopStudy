# 합성과 유연한 설계
- 객체 합성이 상속보다 더 좋은 방법이다. why?
- 상속을 하게 되면 부모, 자식간 사이의 의존성은 컴파일 타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.
    - 즉, 상속은 클래스 사이간 정적 관계이고, 합성은 객체 사이의 동적 관계이다.
- 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만, 합성 관계는 실행 시점에 동적으로 변경이 가능하여 쉽고 유연한 설계가 가능하다.
    - **컴파일 의존성에 속박되지 않고 런타임 의존성을 구성할 수 있는 것이 커다란 장점**
- 합성은 내부에 포함되는 객체의 구현에 의존하지 않고 퍼블릭 인터페이스에 의존하도록 하여 변경에 더 안정적이다.
    - 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경하여 낮은 결합도를 가진다.
- 화이트박스 재사용 : 상속받은 서브 클래스에 의한 재사용 - 자식 클래스에게 부모 클래스의 내부가 공개되기 때문에 화이트
- 블랙박스 재사용 : 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용

<br>

## 상속 오버라이드의 단점
- 상속 문제는 자식 클래스를 부모 클래스를 알아버려서 문제이기에 결합도가 강해진다.
- 오버라이드는 좋지 않다. 왜냐하면 자식클래스가 부모클래스의 구현을 재정의 한다는 것인데 오버라이드시 **LSP 원칙이 깨질 수 있다.**
- LSP 원칙 : 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- 자식 클래스가 부모 클래스의 책임을 무시하면서 오버라이드를 한다면 LSP 원칙이 깨진다.
- `훅 메서드`를 이용해서 `템플릿 메서드 패턴`을 사용한다면 오버라이드의 단점을 완화시킬 수 있다.
    - 훅 메서드란 슈퍼클래스에서 기본 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드
- 템플릿 메서드 패턴을 사용한다면 부모클래스가 자식 클래스를 알기 때문에 사용해도 된다. -> 자식 클래스에게 위임
    - 자식 클래스가 추상 메서드를 오버라이딩함으로써 부모 클래스에 정의한 플로우에 개입이 가능하다.
    - 훅 메서드를 이용해 자식에서 부모가 아닌 부모가 자식을 호출하기 때문에 LSP 원칙이 깨지지 않게 된다.

<br>

## 상속의 목적
- 상속은 위에서 설명했다싶이, 장점보다 단점이 많다. 언제 상속을 써야 할까?
- 부모 클래스의 코드를 재사용 하기 위함도 있지만 **`상속의 진정한 목적은 자식 클래스와 부모 클래스를 동일한 개념적인 범주로 묶어 is - a 관계를 만들기 위해 사용`**

<br>

## 믹스인
- 페이지 379쪽에 믹스인은 `컴파일 시점`에 필요한 코드 조각을 조합하는 재사용 방법이라고 써잇는데 이 부분은 오타 같음
    - 뒤쪽엔 런타임 시점으로 설명하고 있음
- `믹스인`이란 합성처럼 유연하면서 상속처럼 쉽게 코드를 재사용할 수 있는 방법.
- 상속은 정적이지만 `믹스인`은 동적이다.
    - 상속의 결합도 문제를 야기하지 않는다.
    - 물론 상속을 통해 구현하여 코드 관점으론 결합이 된다고 할 순 있겠지만 믹스인을 한다는건 사용 될 수 있는 문맥을 제한하는 것.
```
어떤 A 객체가 여러 구조로 된 부모를 상속 받고 있을때 
해당 A 객체의 여러 부모의 메서드중 하나를 실행할때 어떤 부모의 소속인지 런타임 시점때 정해지는데,
이때 어떤 부모 타입에 소속되어 다양한 형태로 동작할 수 있는 것을 믹스인이라는 것으로 이해함

믹스인은 이름에서 알 수 있는 것 처럼 무언가를 혼합하는 이미지를 가지고 있는 것 같이 
비즈니스 로직에 정렬이 가능하다, 복사가 가능하다, 직렬화가 가능하다 등을 런타임 시점에 여러 형태의 선택적 행위를 가질 수 있다.
따라서 하나의 믹스인은 다양한 클래스를 도출하면서 서로 다른 서브 클래스를 이용해 인스턴스화 될 수 있다.
주 기능에 추가적인 기능을 혼합하는 이미지로 생각하면 좋을 것 같음
```

