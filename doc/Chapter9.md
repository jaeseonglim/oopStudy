# 유연한 설계
## 01. 개방 - 폐쇄 원칙 (OCP, Open Close Principal)
- 확장엔 열려 있어야 하고 수정엔 닫혀 있어야 한다는 원칙
- 확장엔 열려 있어야 한다 ? 
    - 요구사항이 변경될때 변경에 맞게 `동작`을 추가해서 어플리케이션 기능을 확장할 수 있어야 한다.
- 수정엔 닫혀 있어야 한다 ?
    - 기존 `코드`를 수정하지 않고 동작의 추가나, 변경이 가능해야한다.

#### 어떻게 확장엔 열려있고, 수정엔 닫히게 하는가?
- **컴파일 타입 의존성을 고정하고 런타임 의존성으로 변경하는 것**
- 컴파일 의존성은 코드간 클래스들 사이의 관계이고, 런타임 의존성은 협력에 참여하는 객체들 사이의 관계이다.
- **즉, `추상화`에 의존하도록 변경하는것이 핵심**
    - `추상화`란 핵심적인 부분만 남기고 불필요한 부분은 생략한다.
    - 핵심적인 부분이 남는다 == 변하지 않는 부분이 남는다.
        - 문맥이 변하더라도 변하지 않는 부분이 남게되는 것은 다양한 상황에서 공통점을 추출하고 반영한 추상화의 결과물
    - 그렇기 때문에 수정에 닫혀있게 되어 추상화가 OCP가 가능한 이유이다.
- 추상화를 했다고 모든 수정에 대해 폐쇄적은 아니다. 변경되지 않을 부분을 신중히 결정하고, 올바르게 추상화를 하자.


<br>

## 02. 생성 사용 분리
- 결합도가 높아질수록 OCP 구조를 지키는 설계가 어려워진다.
- 특히 객체 생성은 과도한 결합도를 증가시킬 수 있다.
- 추상화에 의존하도록 하기 위해선 도메인 내부에 구현체의 인스턴스를 생성해서는 안된다.
    - 내부에 구현체를 생성했을 경우, 만약 구현체를 변경해야 된다면?
    - 동작을 추가하거나 변경을 위해 기존의 코드를 수정하는 것은 OCP 위반
- 어디선가 객체를 생성해줘야 하는데, 부적절한곳에서 객체를 생성하기 때문에 결합도가 증가하게 된다.

### 생성과 사용의 책임을 분리하라.
- 객체를 생성하고, 사용하는것을 분리하자.
- 생성과 사용을 분리하는 보편적인 방법은 클라이언트에게 생성 책임을 위임하는 것.
    - 클라이언트도 특정 객체에게 메시지를 보내 협력 관계에 속하기 때문에 타당하다고 볼 순 있다.
    - 다만 클라이언트에게도 구현체 정보가 노출되는 단점이 있다.

### FACTORY 추가하기
- 객체 생성에 특화된 `FACTORY`에게 생성 책임을 위임하자.
- GRASP, 책임 할당의 가장 기본이 되는 원칙은 책임을 수행하는데 있어서 가장 정보를 많이 알고 있는 정보전문가에게 책임을 할당하는 것이다.
    - 다만 `FACTORY`는 도메인에 속하지 않는다.    
    - 결합도를 낮추고 재사용성을 높이기 위한 순수한 기술적인 결정
    - 도메인에게 할당되어있던 객체 생성 책임을 도메인과 관련없는 객체로 이동시킨 것 

### 순수한 가공물에게 책임 할당하기
- 시스템을 객체로 분해하는데 `표면적 분해` 와 `행위적 분해`라는 2가지가 존재한다.
- `표면적 분해` : 도메인에 존재하는 사물 또는 개념에 대해 표현하는 객체들을 이용해 시스템을 분해하는 것이다.
    - OOP 설계를 위한 기본적인 접근법
    - OOP 설계의 단점으로는 시스템 구현시, 도메인 개념을 표현하는 객체에게 책임을 할당하는것만으로 부족한 경우가 존재한다.
        - DB에 접근을 위한 객체는 도메인 개념으로 표현할 수 있는가?
        - 도메인 객체에게 책임을 할당할 경우, 낮은 응집도와 높은 결합도, 재사용성 저하 등의 OOP 목적을 위반하게된다면?  
    - 도메인 개념을 벗어나 인의적, 편의상 만든 기계적인 개념도 필요하다.
- `행위적 분해` : 도메인 개념을 표현한 객체가 아닌 인의적, 편의적으로 만든 객체를 이용해 시스템을 분해하는 것.
    - 모든 책임을 도메인에게 할당한다면 문제가 발생할 수 있다.
    - 책임을 할당하기 위해 도메인과 무관하게 창조되는 인공적인 객체를 `순수한 가공물`이라고 한다.
    - 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재 하지 않는 경우 PURE FABRICATION을 생성하고 이 객체에게 책임을 할당하면 된다.
    - 객체지향 어플리케이션에서는 도메인 개념을 반영하는 객체들 보다 인공적으로 창조한 객체들이 더 많은 비중을 차지한다.
- 도메인의 본질적인 개념을 표현하는 객체를 추상화하여 시스템을 구축하도록 시작하고, <br>
도메인 개념이 만족하지 않다면 인공적인 객체를 창조하라.
- 도메인에게 책임 할당시, 응집도가 낮아지고 결합도가 높아진다면 가공의 객체를 추가하여 책임을 옮기도록 고민하자.

<br>

## 03. 의존성 주입
- 생성을 분리하면 객체엔 인스턴스를 사용하는 책임이 남게 된다.
    - 외부에서 다른 객체가 생성된 인스턴스를 전달해야하는 것을 의미한다.
- 외부의 독립적인 객체가 인스턴스를 생성한 후, 이를 전달해서 읜좃ㅇ을 해결하는 방법을 `의존성 주입`이라고 한다.
- 의존성 주입은 의존성을 퍼블릭 인터페이스에 명시적으로 드러내서 필요한 의존성을 외부에서 런타임 시점을 통해 전달할 수 있도록 하는 것.
- 의존성 주입 방법 (8장에서 설명한 내용)
    - 생성자 주입 
    - setter 주입
    - 메서드 주입
    - 인터페이스 주입 : 어떤 대상을 어떻게 주입할 것인지를 인터페이스에 명시적으로 선언하는 기법

### 숨겨진 의존성은 나쁘다
- 의존성 주입 외에도 의존성을 해결할 수 있는 Service Locator 라는 방법이 존재한다
- 의존성을 해결할 객체들을 보관하는 저장소 역할을 하는데, 의존성을 감추는 단점이 존재하여 사용하지 않는다.
- 의존성을 구현 내부로 감출 경우, 컴파일 타임이 아닌 런타임에 발견되어 문제 발생시, 해결 시점은 코드 작성 시점이 아닌 실행 시점으로 미뤄진다.
- 의존성을 숨기면 단위 테스트도 어렵다.
- **숨겨진 의존성이 가지는 가장 큰 문제점은 의존성을 이해하기 위해 코드늬 내부 구현을 이해할 것을 강요한다.**
    - 캡슐화를 위반한다.
- 의존성 주입을 사용하여 외부 인터페이스에 의존성을 명시적으로 노출시키자.

<br>

## 04. 의존성 역전 원칙 (DIP, Dependency Inversion Principal)
- 어떤 협력에서 중요한 정책이나, 의사 결정, 비지니스 로직의 본질을 담고있는 것은 상위 수준의 클래스이다.
- 상위 수준의 클래스가 하위 클래스에 의존하게 되면 하위 수준의 잦은 변경이 상위 수준까지 영향을 미치게 될 것 이다.
- 상위 수준은 어떤식으로든 하위 수준에 의존해서는 안된다.
    - 하위 수준의 변경시 상위 수준도 변경의 영향이 있다면 **확장에 어렵고 변경에 취약한 구조이다.**
    - 즉, OCP를 위반하게된다. (OCP와 밀접한 관계)
- 추상화로 해결한다.
    - 상,하위 수준을 추상화로 의존하도록 한다면 하위 수준의 변경으로 인해 상위 수준에 영향을 받는것을 방지할 수 있다.
    - 상위 수준을 재사용할때, 하위 수준에 얽매이지 않고 다양한 컨텍스트에서 재사용이 가능하다.
- `DIP` 원칙은 다음과 같다.
    - 상위 수준은 하위 수준의 구현에 의존해서는 안된다.
    - 상,하위 모듈은 추상화에 의존해야 한다.
    
### 의존성 역전 원칙과 패키지
- 역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권도 적용된다.
    - 즉, 어느 모듈의 패키지가 인터페이스를 가지는게 맞을까?
- 추상화를 별도의 독립적인 패키지가 아닌 클라이언트가 속한 패키지에 포함시켜야 한다.
    - **인터페이스가 상위 수준 모듈에 속한다**
- 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야한다.
- 이를 Seperated Interface 패턴이라 부른다.
- **`DIP` 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.**
    - 전통적인 패러다임에서는 상위 수준의 모듈이 하위 수준 모듈에 의존했다면
    - 객체지향 패러다임에서는 상위 수준 모듈과 하위 수준 모듈이 모두 추상화에 의존한다.
    - 전통적인 패러다임에서는 인터페이스가 하위 수준 모듈에 속했다면 객체지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.

<br>

## 05. 유연성에 대한 조언
### 유연한 설계는 유연성이 필요할 때만 옳다.
- 유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일 타임 의존성으로부터 런타임 의존성을 만들 수 있는 코드 구조를 가진 설계를 의미한다.
- 하지만 유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다.
- 설계의 미덕은 **단순함과 명확함**으로부터 나온다.
    - 단순하고 명확한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하다.
    - 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함을 버리게 될 가능성이 높다.
- 유연한 설계 이면에는 복잡한 설계라는 의미가 숨어있다.
    - 유연하지 않은 설계는 단순하고 명확하다. 유연한 설계는 복잡하고 암시적이다.
- 불필요한 유연성은 불필요한 복잡성을 낳는다.
    - 유연성과 복잡성을 고려하여 필요성에 맞게 설계와 구조를 가지자.

### 협력과 책임이 중요하다.
- 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요하다.
- 객체들이 메시지 전송자의 관점에서 동일한 책임을 수행하는지 여부를 판단할 수 없다면 추상화를 할 필요가 없다.
- 성급한 객체 생성은 불필요한 객체를 결합시킨다.
- 중요한 비지니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것 보다 우선이다.
- 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다.
- 역할, 책임, 협력에 먼저 집중해야 한다.





