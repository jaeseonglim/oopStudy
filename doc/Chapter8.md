# 의존성 관리하기
- 잘 설계된 객체는 책임이 명확하고, 한가지 일만 잘하도록 분리된 객체
- 이런 작은 객체들은 단독으로 수행될 수 없기에 다른 객체에게 도움을 요청하여 객체간 협력을 통해 일을한다.
- 협력을 하게되면 객체간 존재를 알고 있어야 하기 때문에 의존성이 생길 수 밖에 없다.
- 협력을 하려고 과도한 의존성을 맺는다면 변경이 어려운 설계가 되어 객체지향이 지향하는 목표에 어긋난다.
- 이번 8장을 통해 객체간 협력적이면서 의존성 관리하는 방법을 정리한다.

<br>

## 01. 의존성 이해하기
### 변경과 의존성
- 의존성이란?
    - 변경에 의한 영향의 전파 가능성
- 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
    - 실행 시점 : 어플리케이션 실행시 의존 대상 객체가 반드시 존재해야함
    - 구현 시점 : 의존 대상 객체 변경시, 의존하는 객체도 같이 변경된다.
    ```java
    public class PeriodCondition implements DiscountCondition {
        private DayOfWeek dayOfWeek;
        private LocalTime startTime;
        private LocalTime endTime;
    
        public boolean isSatisfiedBy(Screening screening) {
            return screening.dayOfWeek.equals(dayOfWeek) && 
                   screening.startTime.compareTo(startTime) <= 0 &&
                   screening.endTime.compareTo(endTime) >= 0;
        }  
    }
    ```
    - Screening 인스턴스가 존재하지 않거나 Screening에게 요청하는 메시지들을 이해 못한다면 동작하지 못할 것.
    <br>
    
- **의존성은 방향성을 가지며 항상 단방향이다.**
    - 양방향 의존성을 피해야함 A <-> B
        - A가 변할 경우 B가 변하고 B가 변하면 A도 변하게 된다.
```
    <interface>
    DiscountCondition
            ^       ㅡㅡㅡㅡㅡㅡㅡㅡㅡ> DayOfWeek
            |       
                    ㅡㅡㅡㅡㅡㅡㅡㅡㅡ> LocalTime
            |
    PeriodCondtition - - - - - - -> Screening

```
- 위 그림에선 의존관계를 점 선으로, 연관 관계를 실선으로 표시하였다.
    - 의존 관계 : 특정 클래스에 변화가 있을때 다른 클래스에도 영향을 미치는 관계
        - A 클래스의 메서드가 B 클래스를 파라미터로 받아 사용시
        - A 클래스의 내부에서 B 클래스를 생성하여 사용하는 경우
        - A 클래스의 메서드가 B 클래스를 반환하는 경우
        - 부모 클래스를 상속 받았을 때
    - 연관 관계 : 특정 클래스의 인스턴스가 작업을 수행하기 위해선 다른 클래스를 아는 관계
        ```java
        public class A {
            private final B b;
        }
        ```
- **의존성이 가지는 근본적인 특성은 자신이 의존하는 대상이 변경될 때 함께 변경될 수 있는 킹능성**

<br>

### 의존성 전이
- 의존성은 전이 될 수 있다.
- A가 가지고있는 C클래스의 의존성이 B클래스에게 전파 될 수 있다.
    - B - - - - -> A - - - - -> C
- 모든 경우에 전이되는 것은 아니다.
    - 전이 여부는 내부 구현을 효과적으로 캡슐화한다면 전파되지 않는다.
- 의존성의 종류는 두가지가 있다.
    - 직접 의존성 : 말 그대로 객체의 존재를 직접 알고있는 관계
    - 간접 의존성 : 존재 유무를 모르지만 의존성 전이에 의해 전파되는 관계
    
### 런타임 의존성과 컴파일타임 의존성
- 런타임 의존성 : 객체지향 어플리케이션은 런타임의 주인공은 객체이다.
    - 런타임 의존성은 객체 사이의 의존성을 뜻함
- 컴파일 의존성 : 컴파일 시점은 두가지로 해석할 수 있다.
    1. 작성된 코드를 컴파일 하는 시점
    2. 코드를 작성하는 시점
    - 코드 관점에서 주인공은 클래스이다.
    - 컴파일 의존성은 클래스 사이의 의존성을 뜻함
- 유연하고 재사용하도록 만들기 위해서는 **런타임 의존성과 컴파일 의존성은 서로 달라야 한다.**
    - 두 시점이 같다면 컴파일, 개발, 배포가 불가능해질 것이다.
- p.258 Movie 클래스의 코드를 보면 컴파일 시점에선 할인정책 구현체들의 존재를 모른다.
- 런타임 시점에선 할인정책 구현체들과 협력하게 된다.
- 여러 객체가 협력할 수 있도록 만드는 것은 구현제를 알지 못하게 하고 추상 클래스를 의존하도록 만들고 <br>
컴파일 의존성을 실행 시, 구현체들에 대한 런타임 의존성으로 대체해야 한다.
    - 컴파일시, 구체적인 클래스를 알지 못하게 하자.
    
### 컨텍스트 독립성
- 객체는 자신과 결합할 구체적인 클래스에 대해 아는 것은 좋지 않다. 
- 구현체를 알면 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.
- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 `컨텍스트 독립성`이라고 부른다.
- 독립적인 컨텍스트를 가지려면 실행될 컨텍스트에 대한 구체적인 정보는 최대한 적게 알아야한다.
    - 컨텍스트가 독립적이라면, 어떻게 런타임시 실행 컨텍스트에 적절한 객체들과 협력할 수 있을까?

### 의존성 해결하기
- 컴파일 타임 의존성을 실행 컨텍스트에 맞는 런타임 의존성으로 교체한다.
    - 즉, 객체가 실행되는 시점에 정보를 전달받아야 한다.
- 일반적으로 다음과 같은 3가지 방법으로 해결한다.
    1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
        - 장점 : 불변 객체 유지
        - 단점 : 설계 변경으로 인해 런타임시 의존성 변경 불가능
    2. 객체 생성 후 setter 메서드를 통해 의존성 해결
        - 장점 : 런타임시, 의존 대상 변경 가능
        - 단점 : 객체가 생성된 후 의존 대상을 설정하기 때문에 객체의 상태가 불안정
    3. 메서드 실행 시 인자를 이용해 의존성 해결
        - 지속적으로 의존 관계를 맺을 필요 없고 메서드가 실행되는 동안만 일시적으로 의존관계가 존재해도 무방하거나, 메서드가 실행될 때마다 의존대상이 매번 달라져야 하는 경우에 유용
- 좋은 방법은 생성자 방식과 setter 방식을 혼합하는 것. 항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후, <br>
필요에 따라 setter 메서드를 이용해 의존 대상을 변경할 수 있게 할 수 있다. 이렇게 하면 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있다.

<br>

## 02. 유연한 설계
### 의존성과 결합도
- 의존성은 객체간 협력을 위해 필요하다. 다만, 과한 의존성이 문제이다.
- 의존성이 과하다는건 강한 결합을 하고 있다는 것이다.
- P.265 처럼 구현체와 직접적으로 의존성을 맺게 된다면 재사용이 불가능하다.
- 바람직한 의존성은 재사용의 정도와 관련이 있다.
- 컨텍스트에 독립적인 의존성은 바람직하며, 결합도를 느슨하게 가진다면 바람직한 의존성을 가질 수 있다.
    - 송신 객체 입장에서 메시지만 이해할 수 있는 수신자라면 어떤 타입이든 협력해도 상관 없다.
    - 의존을 맺으려는 타입을 추상적으로 만들 필요가 있다.

### 지식이 결합을 낳는다.
- 결합도의 정도는 자신이 의존하고 있는 다른 요소에 대해 알고있는 정보의 양이다.
- 즉, 외부의 정보를 많이 알수록 강한 결합.
- 결합을 느슨하게 하기 위해선 협력하는 대상들의 필요한 정보만 알고, 그 외에는 최대한 모르도록 감춰야한다.

### 추상화에 의존하라.
- 추상화란 형태, 세부사항, 구조를 좀 더 명확하기 하기 위해 특정 절차나 물체를 생략하거나 감춰 복잡도를 극복하는 방법
- 추상화와 결합도의 관점에서 의존 대상을 다음과 같이 구분할 수 있다.
    ```
    구체 클래스 의존성
         |      -> 구현 은닉
    추상 클래스 의존성
         |      -> 타입 은닉
    인터페이스 의존성
    ```
- **의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다.**
    - 과한, 잘못된 추상화가 된다면 차라리 중복이 효율적이다. [링크](https://velog.io/@leejh3224/%EB%B2%88%EC%97%AD-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%B6%94%EC%83%81%ED%99%94)

### 명시적인 의존성
- 결합도를 느슨하게 만들기 위해서는 타입을 추상 클래스나 인터페이스로 추상화하는것만으로 부족하다.
    - 구현체의 직접적인 모든 의존성을 제거해야한다.
    - 런타임시, 협력을 위해 어떤 인스턴스와 의존할지 알려줘야 한다.
    - 앞에서 말했던 3가지 방법이 존재한다.
- 앞서 3가지 말했던 방법은 퍼블릭 인터페이스에 명시적으로 노출되기 때문에 명시적 의존성이라고 한다.
- 구현체와 직접 의존성을 연결하는 방식은 퍼블릭 인터페이스에 노출되지 않기 때문에 숨겨진 의존성이라고 부른다.
- 의존이 명시적이지 않으면 내부구현을 직접 분석해야 파악이 가능하다.
    - 더 큰 문제는 의존성 변경이 내부 구현을 직접 변경해야한다.
- 의존성을 구현 내부에 숨기지말고 외부에 드러내어 명시적으로 의존성을 표현되도록 하자.

### new는 해롭다.
- 결합도 측면에서는 new가 해로운 이유는 2가지이다.
1. new 연산을 사용하기 위해선 구현체의 이름이 노출된다.
2. new 연산은 어떤 인자를 이용하여 생성되는지 알아야하기 때문에 정보의 양이 많아진다.

- 해결 방법은 인스턴스 생성 로직과 생성된 인스턴스를 사용하는 로직을 분리한다.
    - GOF 디자인 패턴 중 생성패턴에 해당하는 추상 팩토리, 팩토리 메서드 패턴을 이용해도 좋을 것 같다.
    - 생성패턴은 객체 생성에 괸련된 패턴으로써, 특정 객체가 생성되거나 변경되어도 구조에 영향받지 않도록 `생성 책임`만 가지도록 하는 패턴
- 사용과 생성의 책임을 분리하고 의존성을 생성자에 명시적으로 드러내고, 구현체가아닌 추상화에 의존하게 하자.

### 가끔은 생성해도 무방하다.
- 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.
    - 협력하는 기본 객체를 설정하고 싶은 경우
    - 생성자 오버로딩을 통해 가능.

### 표준 클래스에 대한 의존은 해롭지 않다.
- 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다. ex) class in JDK
    - 사실 JDK들도 버전업을 하면서 내부 변화가 있었기에 과연, 변경되질 않을 클래스가 있을까 싶다.
    
### 컨텍스트 확장하기
- Movie의 설계를 할인 혜택을 제공하지 않는 경우와 서로 다른 할인 정책을 중복해서 적용이 가능한 경우로 예를 살펴본다.
- 할인 혜택을 제공하지 않는 경우
    - 할인 정책을 null로 하게되면 null check를 수행하도록 변경되어야 한다.
    - 어떤 경우든 내부를 직접 수정하는건 버그의 발생 가능성이 높다.
    - 예외 케이스가 아닌 할인 혜택을 제공하지 않는 정책에 대한 클래스로 만들어 처리
- 서로 다른 할인 정책을 중복해서 적용이 가능한 경우
    - Movie내부에 List 인스턴스 변수를 가지도록 하게 된다면 기존의 할인 정책 방식과 다른 케이스를 추가해야 한다.
    - 중복 할인 정책을 할인 정책의 한가지로 간주하여 새로운 클래스를 만들어 적용한다.
    ```java
    public class OverlappedDiscountPolicy extends DiscountPolicy {
        private List<DiscountPolicy> discountPolicies;
        
        public OverlappedDiscountPolicy(DiscountPolicy... discountPolicies) {
            this.discountPolicies = Arrays.asList(discountPolicies);
        }
        
        @Override
        protected Money getDiscountAmount(Screening screening) {
            Money money = Money.ZERO;
            for (DiscountPolicy each : discountPolicies) {
                result = result.plus(each.calculateDiscountAmount(screening));
            }
            return result;
        }
    }
    ```
- 즉, 위와 같이 다양한 케이스의 추가도 Movie의 변화없이 협력하는 객체만 변경하도록하여 컨텍스트에서 재사용하도록 하였다.
- 추상화의 자식들을 추가함으로써 컨텍스트 확장이라는 개념이 재사용 가능하도록 결합도를 낮게 해준다.

### 조합 가능한 행동
- 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어 낼 수 있는 설계다.
- 훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 `무엇`을 하는지를 표현하는 설계다.
- `핵심은 의존성을 관리하는 것이다.`

