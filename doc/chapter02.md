## **협력, 객체, 클래스**

1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.

2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.



## **도메인의 구조를 따르는 프로그램 구조**

도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야



## **클래스 구현하기**

**객체** 

1. **상태**와 **행동**을 함께 가지는 복합적인 존재

2. 스스로 판단하고 행동하는 **자율적인 존재**

캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것

접근 제어(access control) : 외부에서의 접근을 통제할 수 있는 메커니즘(접근 수정자(access modifier)를 제공)

퍼블릭 인터페이스(public interface) : 외부에서 접근 가능한 부분

구현(implementation) : 내부에서만 접근 가능한 부분



## **협력에 관한 짧은 이야기**

객체는 다른 객체의 인터피이스에 공개된 행동을 수행하도록 **요청(request)** 할 수 있다.

요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답(response)** 한다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송(send a message)** 하는 것 뿐이다.

다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신(receive a message)** 했다고 이야기 한다.

메시지와 메서드를 명확하게 구분하는 것에서부터 **다형성(polymophism)** 의 개념이 출발한다.



차이에 의한 프로그래밍(programming by difference)

부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법



상속과 인터페이스

상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.

업캐스팅(upcasting) : 자식 클래스가 부모 클래스를 대신 하는 것



다형성

동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.

이를 **지연 바인딩(lazy binding)** 또는 **동적 바인딩(dynamic binding)** 이라고 부른다.

그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 **초기 바인딩(early binding)** 또는 **정적 바인딩(static binding)** 이라고 부른다.



코드 재사용

상속

1. 캡슐화를 위반 - 부모 클래스의 구현이 자식 클래스에게 노출(자식 클래스가 부모 클래스에 강하게 결합)

2. 설계를 유연하지 못하게 만든다 - 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정

합성

인터페이스에 정의된 메시지를 통해서만 코드를 재사용

메시지를 통해 느슨하게 결합
