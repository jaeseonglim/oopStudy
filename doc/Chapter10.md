# Chapter 10. 상속과 코드 재사용

#### 객체지향 프로그래밍의 장점
- 코드 재사용 용이

: 새로운 코드를 추가하는 것

#### 재사용의 가장 대표적인 기법 
상속 / 합성 

#### 상속 
재사용 관점 - 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법

## 01 상속과 중복 코드
### DRY 원칙
#### 중복코드 제거해야하는 이유
- 변경을 방해

새로운 코드를 추가할땐 언젠가 변경 될 것이라고 생각하기

#### 중복코드의 문제
- 코드 수정에 비용 증가

1. 어떤 코드가 중복인지 찾고
2. 모든 코드 수정
3. 모든 코드 테스트해서 동일한 결과인지 확인

#### 중복코드 판단 기준<br/>
- 변경

: 요구 사항 변경시 두 코드 모두 수정해야하는가  /  코드의 모양 X

    DRY = Do Not Repeat Yourself
    동일한 지식을 중복하지 말아라

    = 한 번, 단 한번 원칙(Once and Only Once) <br/>
    = 단일 지점 제어 원칙(Single-Point Control)

모든 핵심은 코드 언에 중복 존재 X

### 중복과 변경
#### 상속을 이용해서 중복코드 제거하기

개별 통화 기간 저장 - Call 클래스 
> 통화 시작 시간(from), 통화 종료 시간(to)

통화(call) 목록을 관리 - Phone 클래스 
> 단위 요금(amount) , 단위 시간 (seconds) , 전체 통화 목록 (call의 리스트) 

+심야 할인 요금제 - NightlyDiscountPhone 클래스 - Phone 클래스 복사 후 수정
> 통화 요금(regularAmount), 밤 통화 요금(nightlyAmount), 단위 시간(seconds)

구현 시간은 절약 
phone & nightlyDiscountPhone - 중복코드 많음 

####중복 코드 수정하기

+부과세율 추가

중복코드를 발견 못했을 수도 있고 같은 내용이지만 두 개를 다르게 작성했을 수도 있다.

#### 타입 코드 사용하기

enum 타입 코드 추가하고 값에 따라 로직 분리

- 낮은 응집도와 높은 결합도

### 상속을 이용해서 중복코드 제거하기

calculateFee 부분 

밤 10시 이후 통화료를 기존에서 마이너스 처리 <br/>
→ 개발자의 가정에 의한 처리 방법

> 상속을 이용해 코드를 재사용 하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야한다. <br/>
 = 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다.

상속 = 결합도 상승 = 코드 수정 어려움

### 강하게 결합된 Phone 과 NightlyDiscountPhone

부과세율을 추가

새로운 중복 코드 만들어야 함 = 너무 강하게 결합되어 있어서 발생하는 문제

    상속을 위한 경고1
    자식 클래스의 메서드 안에서 super 참조를 이용해 부모클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. 
    super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

####취약한 기반 클래스 문제

상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상 

→ 코드 재사용을 목적으로 상속을 사용할 때 발생하는 대표적인 문제

## 02 취약한 기반 클래스 문제

부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상

→ 캡슐화 약화 & 결합도 상승

자식 클래스가 부모클래스의 구현 세부 사항에 의존하도록 만들기 때문에 캡슐화 약화

####객체를 사용하는 이유
구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화 할 수 있기 때문에 

####캡슐화의 가치
변경에 의한 파급효과 제어 가능

####상속을 사용시

부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향 받기 쉬워짐

부모의 작은 변경 → 모든 자손들 요동침

> 객체지향 = 캡슐화를 통한 변경의 통제

상속 = 캡슐화 장점 희석 & 구현에 대한 결합도 높임 
→ 객체지향이 가진 강력함 반감

### 불필요한 인터페이스 상속 문제

java.util.Stack & java.util.properties

두 클래스 모두 부모 클래스에서 상속받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반 될 수 있다

1. java.util.Stack <br/>
    Stack은 LIFO 자료구조 형태

    Vector를 상속 <br/>
     → Vector는 임의의 위치에 요소 조회 추가 삭제할 수 있음

    stack은 마지막 위치에 넣고 첫 위치에서 나와야하는데 vector 때문에 위반 

인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 만들어야 한다. 

2. java.util.properties <br/>
    키와 값의 쌍을 보관한다. 오직 string 만

    generic 도입되기 이젠에 개발했을 땐 키와 값의 타입이 string인지 체크 불가능

    저장은 string 아니어도 되지만 반환이 안됨

고려없이 단순히 코드 재사용을 위해 상속을 이용하는 것은 위험

객체 지향 = 객체들의 협력

단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치하면 안된다.

    상속을 위한 경고 2
    상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

### 메서드 오버라이딩의 오작용 문제

이펙티브 자바 InstrumentedHashSet

```java
@Override
public boolean addAll(Collection<? extends E> c) {
	addCount += c.size();
	return super.addAll(c);
}
```

```java
InstrumentedHashSet<String> languages = new InstrumentedHashSet<>();
languages.addAll(Arrays.asList("JAVA", "RUBY", "SCALA"));
```

addAll 메서드 안에서 add 호출 → HashSet 때문에

addAll에서 add를 한 번 씩 호출 → HashSet과 동일

→ 소스 코드 권한이 없을 수 있고, 
부모 클래스 메서드에서 private으로 사용하고 있을 수도 있음.

    상속을 위한 경고 3
    자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

오버라이딩 가능한 메서드를 호출할 수 있는 어떤 상황에 대해서도 문서화해야 한다.<br/> 
= 무슨 일(what)을 기술하고 어떻게 하는지(how)를 설명해서는 안된다는 통념 어기는 것

상속은 코드 재사용을 위해 캡슐화 희생 <br/>
→ 완벽한 캡슐화를 원한다면 코드 재사용 포기 or 상속 이외의 다른 방법 사용

### 부모 클래스와 자식 클래스의 동시 수정 문제

PlayList - 음악 목록을 저장
> 트랙에 노래 추가 append 메서드

Song - 음악 정보 저장
> 가수의 이름(singer) 변수<br/>
> 노래 제목(title) 변수

+노래 삭제할 수 있는 기능 추가된 PersonalPlayList <br/>
 → Playlist 재사용

+노래의 목록 말고 가수별 노래의 제목 관리 추가

→ append 수정<br/>
→ remove 수정

상속을 받지 않았음에도 불구하고 부모 클래스 수정 할 때 자식 클래스도 수정해야 함.

→ 상속을 사용 <br/>
→ 결합도가 높아지기 때문에 문제 해결 X

결합도 = 다른 대상에 대해 알고 있는 지식의 양

    상속을 위한 경고 4 
    클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 
    자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

## 03 Phone 다시 살펴보기

### 추상화에 의존하자

코드 중복을 제거하기 위해 상속 도입시 

1. 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라<br/>
두 메서드를 동일한 형태로 보이도록 만들 수 있다.
2. 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라<br/>
재사용과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

### 차이를 메서드로 추출하라

- 변하는 것으로부터 변하지 않는 것을 분리하라
- 변하는 부분을 찾고 이를 캡슐화하라

calculateFee → calculateCallFee

### 중복 코드를 부모 클래스로 올려라

AbstractPhone 상속 → Phone

→NightlyDiscountPhone

### 추상화가 핵심이다

아래의 경우에만 코드변경

- AbstractPhone - 전체 통화 목록
- Phone - 일반 요금제의 통화 한 건을 계산하는 방식
- NightlyDiscountPhone - 심야 할인 요금제의 통화 한 건

→ 하나의 변경 이유 : **단일 책임 원칙** → 응집도 높음

Phone & NightlyDiscountPhone 

AbstractPhone의 내부에 있는 추상 메서드 calculateCallFee에 의존 →낮은 결합도

AbstractPhone 또한 추상 메서드 호출 → 추상화에 의존

**의존성 역전 원칙** 준수

자식들이 부모에 의존하기 때문에 / 부모가 자식에 의존 X

새로운 요금제 추가 시

1. AbstractPhone 상속
2. calculateCallFee 오버라이딩

확장에는 열려 있고 수정에 닫혀 있는 **개방-폐쇄 원칙** 준수

### 의도를 드러내는 이름 선택하기

AbstractPhone -> Phone

Phone -> RegularPhone

### 세금 추가하기

클래스의 상속은 행동뿐 아니라 인스턴스 변수에 대해서도 결합

인스턴스 변수의 목록이 변하지 않는 상황에서 행동만 변경된다면 각 클래스들을 독립적으로 진화 가능하지만, 

인스턴스 변수가 추가될 때는 변수 초기화 문제로 자식 클래스의 초기화 로직에 영향을 끼치게 된다.

하지만 인스턴스 초기화 로직을 변경하는 것이 코드 중복보다 현명한 선택이다.

## 04. 차이에 의한 프로그래밍

기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법 = 차이에 의한 프로그래밍

상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용 가능하므로 애플리케이션의 점진적인 정의가 가능

### 목표

중복 코드 제거하고 코드 재사용

재사용 가능한 코드 = 심각한 버그가 존재하지 않는 코드

객체 지향에서 중복 코드 제거 & 코드 재사용 할 수 있는 가장 유명한 건 **상속**

상속이 코드 재사용에 가장 강력한 도구이지만, 강력한 만큼 잘못 사용할 경우에 돌아오는 피해 역시 크다.

상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만드므로 필요한 경우에만 사용해야 한다.