# 메시지와 인터페이스
- 개발할때 보통 클래스가 중심이 되는데, 클래스라는 "구현 도구"에 지나치게 집착하게되면 유연하지 못한 결과물이 도출된다.
- `협력`안에서 객체가 수행하는 `책임`에 초점을 맞추자.
- `책임`은 객체가 수신할 수 있는 `메시지` 기반이다.
- 어플리케이션은 클래스로 구성되지만 `메시지`를 통해 정의가 된다.
- `메시지`들이 객체의 `퍼블릭 인터페이스`를 구성한다.

<br><br>

## 협력과 메시지
### 클라이언트 - 서버
- `메시지`는 객체 사이에 `협력`을 가능하게 만드는 매개체
- 객체가 다른 객체에 접근하는 유일한 방법은 `메시지`를 통해서만 가능하다.
- 객체가 독립적으로 수행하는 것보다 더 큰 `책임`을 수행하기 위해선 `메시지`를 통해 두 객체가 `협력`하도록 한다.

### 메시지와 메시지 전송
- 객체들이 협력하기 위한 의사소통 수단 = `메시지`
- `메시지`는 `오퍼레이션`명, 인자, 메시지 수신자로 구성된다.

### 메시지와 메서드
- `메시지`를 수신했을때 실제로 수행되는 함수를 메서드라고 한다.
- 동일한 `메시지`를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다.
    - 실행 시점에 연결되기 때문 (느슨한 결합)

### 퍼블릭 인터페이스와 오퍼레이션
- 외부에서 볼때 객체의 안쪽은 블랙 박스처럼 검은 장막으로 가려짐
- 오직 객체가 공개하는 `메시지`를 통해서만 `협력`한다.
- 객체가 의사소통을 위해 외부에 공개하는 `메시지`의 집합을 `퍼블릭 인터페이스`라 한다.
- `퍼블릭 인터페이스`에 포함된 `메시지`를 `오퍼레이션`이라 한다.
    - 인터페이스의 각 요소는 `오퍼레이션`이다.

### 시그니처
- `오퍼레이션`(메서드)의 이름과 인자를 합쳐 `시그니처`라고 한다.
- `오퍼레이션`은 구현 코드 없이 `시그니처`만 정의한 것이다.
- `오퍼레이션`의 관점에서 다형성의 축복을 받기 위해선 서로 다른 메서드들이 실행 되는 것이다.
- **객체가 수신할 수 있는 `메시지`가 객체의 `퍼블릭 인터페이스`와 그 안에 포함된 `오퍼레이션`을 결정함으로써 객체의 품질을 결정한다.**

<br><br>

## 인터페이스와 설계 품질
- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스 조건을 만족하는 것이다.
    - 최소한의 인터페이스란 ? -> 최소한의 오퍼레이션을 가진다.
    - 추상적인 인터페이스란 ? -> 어떻게 수행하는지가 아닌 **`무엇`을 하는지 표현하는 것**
    
- 책임 주도 설계 방법을 따르면 좋은 인터페이스를 추출할 수 있다.
1. `메시지`를 먼저 선택함으로써 `협력`과 무관한 `오퍼레이션`이 생기는걸 방지해 최소한의 오퍼레이션만 가진다.
2. 메시지가 객체를 선택하게 하여 의도를 표현함으로써 추상적인 인터페이스가 만들어진다.

- 퍼블릭 인터페이스의 품질을 결정짓는 원칙들을 알아보자.
1. `디미터의 법칙`
    - 객체의 내부 구조를 강하게 결합되지 않도록 `협력` 경로를 제한하는 원칙
    - 낯선자에게 말을 걸지 말라. (낯선 객체와는 소통하지 말라)
    - 인접한 이웃하고만 말하라. (친한 객체하고만 소통하라)
    - 하나의 (.)만 사용하는걸 지향하자. 다른 객체를 탐색해 액션을 일어나게 하지 않도록. 메서드 체이닝과는 무관
    - `디미터의 법칙`을 위반한다면 하나의 변화에 수많은 객체들이 변경될 수 있기에 설계가 무너질 수도 있다. (결합도 상)
    - 객체 노출을 제한하기 위해(디미터의 법칙을 지키기 위해) 객체의 모든 메서드는 다음과 규칙을 따른다.
        - 객체 자신의 메서드 사용
        - 파라미터로 넘어온 객체의 메서드만 호출
        - 메서드 내부에 생성된 객체의 메소드만 호출
        - 인스턴스 변수로 가지고 있는 `연관관계`의 객체의 메소드만 호출
    - `기차 충돌` : 여러 객체가 한줄로 이어진것 처럼 내부구조를 물어보고 연쇄적으로 `메시지`를 전송
    - 객체일경우 `디미터의 법칙`을 고려해야 하지만 자료구조라면 지킬 필요가 없다.
        - 객체는 내부 구조를 숨겨야 하지만 자료구조는 자료를 공개하기 때문에 (클린 코드 6장 참고)

2. 묻지 말고 시켜라 (Don't tell ask)
    - 절차지향은 정보를 얻은 후 결정하는데 객체지향은 그것을 하도록 시킨다.
    - 이 원칙을 따르도록 한다면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가지게 된다.
    
- 이 두가지 원칙을 지킨다면 퍼블릭 인터페이스의 품질은 향상된다.
- 객체는 자신이 내부적으로 보유하고 있는 정보와 메시지 전송의 결과로 의사결정을 내린다.

### 의도를 드러내는 인터페이스
- 메서드 네이밍시 해당 작업은 어떻게 수행하는지 나타내는 명명은 좋지 않다.
    - isSatisfiedByPeriod(), isSatisfiedBySequence()는 좋은 명명이 아니다.
        - **캡슐화를 위반함 (내부 구현 설명)**
        - 메시지를 수신하는 객체들에게 객체의 종류를 알도록 강요하는 사례이다.
    - 이른 시점부터 내부 구현을 고민할 필요는 없다.
- 네이밍은 어떻게가 아니라 `무엇`을 하는지 표현하는 것이다.
    - 네이밍시 메시지 전송의 목적을 먼저 생각하여 책임을 고민한다.
    - 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커져 다양한 타입의 객체가 협력에 참여할 수 있다.
- 네이밍시 의도를 드러내도록 무엇을 수행하는지 표현하자.
- 해당 개념을 인터페이스로 확장시킬 수 있다.

### 함께 모으기
- `디미터의 법칙`을 위반한 설계는 인터페이스와 구현의 분리 원칙을 위반한 것이다.
- `디미터의 법칙`과 묻지 말고 시켜라 원칙을 지키게 된다면 자율적인 객체로 구성되어 유연한 협력을 얻을 수 있다.
    - 구현이 퍼블릭 인터페이스에 노출되지 않아 결합도가 낮아지는 장점을 얻는다.

### 인터페이스에 의도를 드러내라
- 디미터의 법칙은 협력 설계시 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록하고
- 묻지 말고 시켜라 원칙은 디미터 법칙을 준수하는 협력을 만들기 위해 스타일을 제시한다.
- 의도를 드러내는 인터페이스는 코드의 목적을 명확하게 전달한다.

## 원칙의 함정
- 물론 위의 2가지 원칙들은 무조건 절대적으로 지켜야 하는것은 아니다.
- 원칙이 부적합하다고 생각된다면 과감하게 무시할 필요가 있다.
    1. 디미터의 법칙은 하나의 (.)를 강제하는것이 아니다.
        - 메서드 체이닝, 람다와 같은 문법을 예로 들 수 있다.
    2. 결합도와 응집도의 충돌
        - 클래스는 하나의 변경의 원인만을 가져야 한다.
        ```java
        public class PeriodCondition implements DiscountCondition {   
            public boolean isSatisfiedBy(Screening screening) {
                return screening.getStartTime().getDayOfWeek().equals(dayOfWeek) &&
                       startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                       endTime.compareTo(screening.getStartTime().toLocalTime()) >= 0;
            }
        }
        ```
        - 위 코드는 Screening 내부 상태를 가져와서 사용하기때문에 캡슐화를 위반한 사례라고 볼 수 있다.
        - 할인 여부를 판단하는 로직을 Screening에게 옮긴다면 캡슐화를 지키고 묻지말고 시켜라 원칙도 지킬 수 있다.
        ```java
        public class Screening {   
           public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {
               return whenScreened.getDayOfWeek().equals(dayOfWeek) &&
                      startTime.compareTo(whenScreened.toLocalTime()) <= 0 &&
                      endTime.compareTo(whenScreened.toLocalTime()) >= 0;
            }
        }
        ```
        - 하지만 위와 같이 변경되면 Screening에게 할인 조건을 판단하는 책임을 위임하게 된다.
        과연 Screening이 수행할 책임이 맞을까?
        - Screening의 캡슐화를 향상시키는 것보다 Screening의 응집도를 높이고 Screening과 PeriodCondition 사이의 결합도를 낮추는 것이
        전체적으로 더 좋다.
        
- **원칙을 맹목적으로 따르지 말고 트레이드 오프 하자**

<br><br>

## 명령 - 쿼리 분리 원칙
- 질문이 답변을 수정해서는 안된다. 명령과 쿼리를 뒤섞으면 실행 결과 예측이 어려울 수 있다.
- Command (명령) (tell) : 객체 내부 상태를 변경한다면 결과괎을 반환하지 않는 명령만을 수행하는 메서드
- Query   (쿼리) ( ask) : 객체 내부 상태를 변경없이 결과값만 제공하는 질의 메서드

### 명령 - 쿼리 분리와 참조 투명성
- 메서드를 나누게 된다면 메서드 제어가 쉬워진다.
- 쿼리는 객체의 상태를 변경하지 않기 때문에 몇번이고 반복하고 순서를 변경해도 상관없다.
- 명령이 쿼리에 개입하지 않는한 값은 변경되지 않아 결과 예측이 쉽다.
- 명령과 쿼리를 분리함으로써 `참조 투명성`을 얻을 수 있다.
    - `참조 투명성` : 어떤 표현식이 있을때 표현식을 값으로 변환해도 결과는 달라지지 않는 특성
    - 결과가 변하지 않기 때문에 부수 효과로 불변성을 얻을 수도 있다.
- 개인적으로는 CQS도 100% 지킬 수 없는 예외 상황이 존재한다고 생각한다.
- 예로 다음과 같이 질문 글을 삭제할때 다음과 같은 요구사항이 있다고 가정한다.
    - 질문을 삭제할 때 삭제 상태(deleted)를 변경한다.
    - 질문 삭제 이력에 대한 정보를 DeleteHistory를 활용해 남긴다.
    ```java
    public class Question {  
        private boolean deleted = false;
  
        public DeleteHistories delete(final LocalDateTime now) {  
            setDeleted(true); 
            DeleteHistories deleteHistories = deleteQuestion(now);
            return deleteHistories;
        }
  
        private setDeleted(final boolean isDelete) {
            this.deleted = isDelete;
        }
    }
    ```
- 해당 Question의 delete() 메서드는 명령인가 쿼리인가?, 명령과 쿼리의 분리는 어떻게 할 것인가?

- 해당 케이스 같은 경우는 예외라고 생각한다.
- **삭제라는 논리적인 개념은 보통 트랜잭션이 같이 묶여야 되는것 처럼** 상태 변경과 결과값 반환은 같이 묶여야 된다고 생각한다.
- 또한 반환하는 값은 객체의 상태와 관련없기 때문에 해당 메서드는 CQS 원칙을 준수하지 않아도 괜찮지 않을까 한다.
- 처음엔 delete() 메서드는 값을 반환하기 때문에 쿼리라고 생각했었는데 다시 생각해보니 CQS를 지키기 어려운 예외 케이스라고 생각하며 굳이 분류하자면 명령으로 분류된다고 생각한다.
- 해당 메서드가 쿼리일 경우 명령이 개입되면 문제가 되겠지만 해당 메서드 같은 경우는 쿼리가 아닌 명령으로써 다른 쿼리에도 개입되지 않는 부분이기에
- this.deleted = true와 같이 상태를 변경해도 무방하다고 생각되며 삭제와 같은 논리적인 개념으로써 결과값도 같이 반환해야 된다고 생각한다.
- 상태 변경 메서드를 Question 객체 내부에서 다루지말고 외부에서 제어 할 수 있도록 public으로 분리 해보자.

### 책임에 초점을 맞춰라
- 앞선 디미터의 법칙, 묻지말고 시켜라 원칙, 의도를 인터페이스에 드러나도록 준수하는 쉬운 방법은 책임 주도 설계 원칙을 따르는것
    - 구현 이전에 협력에 초점을 맞추고, 메시지를 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것
- 메시지가 객체를 선택하면 협력에 적합한 메시지를 결정하는 확률이 높아져 두 객체사이의 결합도를 낮출 수 있다.
- 클라이언트는 무엇을 원하는지 의도가 분명하게 드러난다.
- 객체가 어떤일을 해야하는지 뿐만 아니라 결과 예측이 가능한 협력을 만들기 위해 CQS를 지키게 될 것이다.
- 다만 구체적으로 실행시점에 필요한 제약이나 조건을 정할 수가 없다.
    - 계약에 의한 설계를 통해 해결할 수 있다. (부록 A)
    



        
    
    
     



