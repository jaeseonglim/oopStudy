# Ch6. 메시지와 인터페이스

훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향<br/>
= 협력 안에서 객체가 수행하는 책임에 초점<br/>
= 책임은 객체가 수신할 수 있는 메시지의 기반

```
애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다
    - 루비로 배우는 객체지향 디자인, 4장 유연한 인터페이스 만들기
```
[루비로 배우는 객체지향 디자인 책 요약 - 시미라이의 일상기록과 서평](https://digiry.tistory.com/entry/practialobject-orienteddesignedinruby)

객체가 수신하는 메시지들 = 객체의 퍼블릭 인터페이스

## 01. 협력과 메시지
### 클라이언트 - 서버 모델
``` 
협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
    - 오브젝트 디자인: 소프트웨어 개발의 성공 열쇠
    - 오브젝트 3장(75pg)
```

클라이언트
* 협력 안에서 메시지를 전송하는 객체

서버
* 메시지를 수신하는 객체

> 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
```
객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다.
메시지 = 두 객체 사이의 협력을 가능하게 해주는 매개체
```

### 메시지와 메시지 전송
* 메시지 <br/>
객체들이 협력하기 위해 사용 하는 수단<br/>
├─ 오퍼레이션 명<br/>
└─ 인자

* 메시지 전송 / 메시지 패싱<br/>
객체가 다른 객체에게 도움을 요청하는 것<br/>
├─ 오퍼레이션 명<br/>
├─ 인자<br/>
└─ 메시지 수신자
 
* 메시지 전송자<br/>
메시지 전송하는 객체 (ex - 클라이언트)

* 메시지 수신자<br/>
메시지 수신하는 객체 (ex - 서버)

### 메시지와 메서드
* 메서드<br/>
메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저<br/>

> 동일한 이름의 변수에게 동일한 메시지 전송해도 객체 타입에 따라 실행되는 메서드가 다를 수 있다.

메시지 전송자는 어떤 메시지를 전송해야 하는지만 알면 되고<br/>
메시지 수신자는 메시지 도착했다는 사실만 알면 된다.
```
메시지를 메서드에 바인딩하는 것은 일반적인 프로시저 호출의 관점에서 아주 작은 변화처럼 보이지만 이 작은 변화가 커다란 차이를 만든다.
```

### 퍼블릭 인터페이스와 오퍼레이션 & 시그니처 
* 퍼블릭 인터페이스 <br/>
객체가 의사소통을 위해 외부에 공개하는 메시지의 집합

* 오퍼레이션<br/>
퍼블릭 인터페이스에 포함된 메시지<br/>
수행 가능한 어떤 행동에 대한 추상화<br/>
실행 코드 없이 시그니처만을 정의

* 메서드<br/>
실행되는 코드<br/>
시그니처 + 구현

* 시그니처<br/>
오퍼레이션(또는 메서드)의 이름 + 파라미터 목록

```
client가 메시지 전송하면 오퍼레이션 호출해서 server에서 메서드를 실행!
메시지 전송 = 오퍼레이션 실행

오퍼레이션 관점에서 다형성
  => 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것
```

## 02. 인터페이스와 설게 품질
좋은 인터페이스
1. 최소한의 인터페이스<br/>
    꼭 필요한 오퍼레이션만을 인터페이스에 포함
    
2. 추상적인 인터페이스<br/>
    어떻게 수행하는지 X / 무엇을 하는지 O

가장 좋은 방법 = 책임 주도 설계 방법
```
책임 주도 설계 방법 ( 3장 83, 84pg )
- 데이터보다 행동을 먼저 결정
- 협력이라는 문맥 안에서 책임을 결정
```

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
- 디미터 법칙
- 묻지말고 시켜라
- 의도를 드러내는 인터페이스
- 명령 - 쿼리 분리

### 디미터의 법칙
= 최소 지식의 원칙

    Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.
    - 각각의 유닛(each unit)은 다른 유닛들(other units)에 대해서 오직 최소의(제한된) 정보만 갖고 있어야 한다 : 현재 유닛(each unit)에 '가깝게' 관련된 유닛들(other units)이어야만 한다.

    Each unit should only talk to its friends; don't talk to strangers.
    - 각각의 유닛은 오직 친구 유닛들에게만 말을 걸어야 한다. : 모르는 사람에게 말 걸지 마라.

    Only talk to your immediate friends.
    - 오직 너의 아주 가까운(immediate) 친구들에게만 말을 걸어라.
    
[디미터의 법칙 - TOAST Meetup](https://meetup.toast.com/posts/215)

모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서 M이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다.<br/>
이 때 M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다.

- M의 인자로 전달된 클래스 ( C자체를 포함 )
- C의 인스턴스 변수의 클래스 


이해가 어렵다면 

클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송

- this 객체
- 메서드의 매개변수
- this 의 속성
- this 의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

#### 부끄럼 타는 코드 (shy code)
불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드

#### 기차 충돌(train wreck)

```
screening.getMovie().getDiscountConditions();
```

위의 예제처럼 전송자가 수신자의 내부구조에 대해 물어보고 반환받는 등 연쇄적으로 메시지를 전송하는 형태

일련의 getter들이 기차의 객차처럼 상호 연결되어보이는 코드

```
객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지
객체가 자기 자신을 책임지는 자율적인 존재여야 한다.
```


### 묻지 말고 시켜라
객체의 상태에 관해 묻지말고 원하는 것을 시킨다

묻지말고 시켜라 원칙에 따르도록 메시지를 결정하다 보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.

상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션을 대체함으로써 인터페이스를 향상시켜라.

```
객체가 어떻게 작업을 수행하는지를 노출하지 말고
인터페이스는 객체가 무엇을 하는지 서술할 것
```


### 의도를 드러내는 인터페이스

#### 메서드 명명 방법
1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓기
   -> 내부의 구현 방법을 드러냄

2. `어떻게`가 아니라 `무엇`을 하는지 드러내기<br/> 
    -> 의도를 드러내는 선택자
   
####좋지 않은 방법
```
isSatisfiedByPeriod 
isSatisfiedBySequence

=> isSatisfiedBy & DiscountCondition interface
```

- 내부 구현 이해 못하면 두 메서드가 동일한 작업을 수행하는지 모름
- 캡슐화 위반 ( 설계 변경에 취약 )

#### 의도를 드러내는 인터페이스
구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현

```
- 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여하라
- 문제를 내되 문제를 푸는 방법을 표현하지 말아라
```

### 함께 모으기
```
* 디미터 법칙 위반 = 인터페이스와 구현의 분리 원칙을 위반
* 인터페이스 이름에서 의도가 드러내게 하라
```


## 03. 원칙의 함정
원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라
```
원칙 = 반드시 지켜야하는 것(=must)
패턴 = 지키면 좋은 것(=should)
```
[패턴과 원칙의 차이점](https://qastack.kr/software/153586/difference-between-pattern-and-principle)


### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.

#### 디미터 법칙
- 결합도와 관련
- 객체의 내부 구조가 외부로 노출되는 경우로 한정

```
IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();
```
- 내부구조 노출 X
- 객체의 내부 내용 묻지 X


### 결합도와 응집도의 충돌

상태 묻기 -> 결정 -> 상태 변경

> 묻는 대상이 객체인지 자료구조인지

#### 단점
- 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존
- 책임들 한 번에 떠안아 응집도 ↓

```
원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라
```

## 04. 명령 - 쿼리 분리 원칙
퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침
```
질문이 답을 수정해서는 안된다.
```

* 루틴<br/>
어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈 
├─ 프로시저<br/>
└─ 함수

* 프로시저<br/>
정해진 절차에 따라 내부의 상태를 변경<br/>
부수효과를 발생시킬 수 있지만 값을 반환 불가능

* 함수<br/>
절차에 따라 필요한 값 계산해서 반환<br/>
값을 반환할 수 있지만 부수효과를 발생 불가능

* 명령 <br/>
객체의 상태를 수정하는 오퍼레이션<br/>
( 개념적으로 = 프로시저 )

* 쿼리<br/>
객체와 관련된 정보를 반환하는 오퍼레이션<br/>
( 개념적으로 = 함수 )


```
어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다
``` 

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경 할 수 없다.

#### 명령-쿼리 인터페이스
명령-쿼리 분리 원칙에 의해 작성된 객체의 인터페이스

### 반복 일정의 명령과 쿼리 분리하기
```java
public class Event {
    public boolean isSatisfied(RecurringSchedule schedule) {
        if(from.getDayOfWeek() != schedule.getDayOfWeek() ||
            !from.toLocalTime().equals(schedule.getFrom()) ||
            !duration.equals(schedule.getDuration())) {
                reschedule(schedule);
                return false;
            }
        return true;
    }
    
    private void reschedule(RecurringSchedule schedule) {
        from = LocalDateTime.of(from.toLocalDate().plusDays(daysDistance(schedule)),
            schedule.getFrom());
        duration = schedule.getDuration();
    }

}
```

*isSatisfied 메서드*
- 조건에 부합하는지 판단 후 true, false 반환<br/>
개념적으로 쿼리
- 조건에 부합하지 않을 경우 부합하도록 변경<br/>
실제로는 부수효과


```
겉으로 보기에는 쿼리처럼 보이지만 내부적으로 부수효과를 가지는 메서드
이해하기 힘들고, 잘못 사용하기 쉬우므로 => 명령과 쿼리 명확하게 분리
```

```java
public class Event {
    public boolean isSatisfied(RecurringSchedule schedule) { // 쿼리
        if(from.getDayOfWeek() != schedule.getDayOfWeek() ||
            !from.toLocalTime().equals(schedule.getFrom()) ||
            !duration.equals(schedule.getDuration())) {
                
                // reschedule 삭제함으로 명령, 쿼리 분리
            
                return false;
            }
        return true;
    }
    
    // private -> public
    public void reschedule(RecurringSchedule schedule) { // 명령
            from = LocalDateTime.of(from.toLocalDate().plusDays(daysDistance(schedule)),
                schedule.getFrom());
            duration = schedule.getDuration();
    }   

}
```

### 명령 - 쿼리 분리와 참조 투명성
#### 참조 투명성
어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성

```
f(1) = 3 이라면 
f(1)로 수식을 했을 때 = 3으로 수식을 했을 때

=> 불변성(immutability) = 값이 변하지 않는 성질
```

#### 장점
- 모든 함수를 이미 알고 있는 하나의 결과값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
- 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.

```
값이 불변 한다 = 부수효과가 발생하지 않는다 = 참조 투명성이다
```

~ 명령형 프로그래밍 & 함수형 프로그래밍 ~
- 명령형 프로그래밍 <br/>
부수효과를 기반으로 하는 프로그래밍 방식 <br/>
상태를 변경시키는 연산들을 적절한 순서대로 나열

- 함수형 프로그래밍<br/>
부수효과가 존재하지 않는 수학적인 함수에 기반하는 방식 <br/>
참조 투명성의 장점 극대 <br/>
실행 결과를 이해하고 예측하기 쉬움

|    | 명령형 프로그래밍 | 함수형 프로그래밍 |
|----|----------------|----------------|
|   종류   | 루프, 조건 및 함수(메서드) 호출| 재귀를 비롯한 함수 호출 및 고차함수|
|   언어   |  C, C++, JAVA  | 스칼라, 하스켈 등 |
|   중점   | 작업을 수행하는 방법(알고리즘)과 상태의 변경을 추적하는 방법 | 원하는 정보와 필요한 변환 |
| 실행 순서 |   중요   | 중요도 낮음 |
|  상태변경 |    중요    |  중요 X  |
| 주요 조작 단위 | 클래스나 구조체의 인스턴스 | 1급(first-class) 개체와 데이터 컬렉션인 함수 |

[왜 함수형 프로그래밍이 더 좋을까?](http://ruaa.me/why-functional-matters/)

### 책임에 초점을 맞춰라
위의 3가지를 한꺼번에 할 수 있는 아주 쉬운 방법!

객체의 구현 이전에 `객체 사이의 협력`에 초점을 맞추고 협력 방식을 단순하고 유연하게 만듦

```
- 디미터 법칙
- 묻지말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리 원칙
```
#### 책임 주도 설계
객체가 메시지 선택 X <br/>
메시지가 객체를 선택 O

=> 협력에 적합한 메시지를 결정할 수 있는 확률 ↑


#### 계약에 의한 설계
협력을 위해 클라이언트와 서버가 준수해야 하는 제약을 코드 상에 명시적으로 표현하고 강제
