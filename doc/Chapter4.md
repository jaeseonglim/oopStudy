# 설계 품질과 트레이드 오프
- 객체지향 설계에서 가장 중요한 것은 올바른 책임을 할당하는 것
- 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질이 연관되어 있으며 높은 응집도와 낮은 결합도로 구성되어야 함
- 객체를 데이터 집합으로 바라본다면 객체 내부 구현을 퍼블릭 인터페이스에 노출될 수 있기때문에 변경에 취약해진다.
- 데이터가 아닌 행동에 초점을 맞춰 설계할 것.

## 데이터 중심의 영화 예메 시스템
- 두가지 방법으로 객체 분할이 가능하다.
    - `상태 분할의 중심축`
        - 데이터를 조작하는데 필요한 행동을 정의
    - `책임 분할의 중심축`
        - 행동을 수행하기 위해 필요한 상태를 정의
- 데이터 중심이 아닌 책임에 초점을 맞춰야 한다.
- 객체의 상태는 구현에 속하므로, 구현은 불안정하기 때문에 잦은 변경이 일어난다. 변경에 취약해진다.
- 책임은 인터페이스 뒤로 필요한 상태를 캡술화 함으로써 변경에 안정적인 설계를 얻을 수 있다.

## 설계 트레이드 오프
### 캡슐화
- 상태와 행동을 모으는 이유 : 내부 구현을 외부로 감추기 위해
- 객체를 사용하면 변경 가능성이 높은 부분은 내부로 숨기고, 외부에는 안정적인 부분만 공개
- 변경 가능성이 높은 부분을 `구현`이라 한다. 외부에 안정적인 부분만 공개하는 것을 `인터페이스`라 한다.
- 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는것

### 응집도와 결합도
- 응집도 : 모듈에 포함된 데이터와 행동들이 연관되어있는 척도
- 결합도 : 객체간 의존하고 있는 척도, 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
   
- 하나의 모듈의 변경이 전체 모듈의 영향을 끼지면 응집도가 낮고, 하나의 변경이 하나의 모듈만 변경되면 응집도가 높은것
- 결합도가 높으면 하나의 모듈을 수정할때 많은 모듈을 함께 수정해야 한다. 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경이 이루어진다.
- 의존성을 약하게 하는 방법 : 모듈이 인터페이스와 의존하게 하고, 객체 생성 책임을 내부가 아닌 외부로부터 주입받는 DI
    - ex) Random, 날짜 https://jojoldu.tistory.com/451

## 데이터 중심의 영화 예매 시스템의 문제점
- 데이터 중심은 캡슐화를 위반하고 객체의 내부 구현을 인터페이스의 일부로 만든다.
    - 캡슐화 위반
    - 높은 결합도
    - 낮은 응집도
- 책임 중심은 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화 한다.
- 과도한 getter / setter 사용은 캡슐화를 위반한다.

## 높은 결합도
- ReservationAgency 코드

## 낮은 응집도
- ReservationAgency 코드
- 서로 다른 코드들을 하나의 모듈안에 뭉쳐놓았기 때문에 다수가 영향을 받음.
- SRP (Single Responsibility Principle) 단일 책임 원칙
    - 객체는 하나의 책임만을 가진다는 원칙.
    - 그렇기에 객체의 변경이 일어난다면 한가지의 이유만을 가져야 한다.

## 자율적인 객체를 향해
### 캡슐화를 지켜라
- 객체는 스스로의 상태를 책임져야하며 외부에 공개해서는 안된다.
- 인터페이스에 정의된 메서드를 통해서만 상태에 접근하도록 한다.
- Rectangle 코드

### 스스로 자신의 데이터를 책임지는 객체
- 캡슐화를 하는 이유 : 객체 스스로 자신이 상태를 처리할 수 있게
- 객체 설계시 어떤 데이터를 포함하는가? 보다 어떤 행동을 수행하는가가 중요하다.
- **새로운 데이터 타입을 만들 수 있다는 것**

## 하지만 여전히 부족하다.
### 캡슐화 위반
- DiscountCondition은 자기 자신의 데이터를 이용해 할인 가능 여부를 스스로 판단한다.
하지만 속성으로 포함된 DayOfWeek와 LocalTime을 파라미터로 받는다. isDiscountable()
즉 외부에 속성을 노출하는것과 다름없다.
- Movie 또한 3가지의 할인 종류가 존재한다는 정보를 노출한다.
- 캡슐화는 객체 내부 데이터를 외부로 감추는것 뿐만 아니라 변하는 개념까지 캡슐화 해야한다.

### 높은 결합도
- 할인을 판단하는 책임이 Movie에게 있기 때문에 Movie와 DiscountCondition 사이의 결합도는 높다.
- isDiscountable()               

### 낮은 응집도
- 위에서 언급한 할인 조건이 변경이 된다면 Screening도 영향을 받음.
- 즉, 하나의 변경을 하기 위해선 코드 여러곳을 수정해야 한다는건 응집도가 낮다는 증거
- 응집도가 낮다는건 캡슐화를 위반한 것.

## 데이터 중심 설계의 문제점
- 데이터를 빠르게 결정하게 된다.
- 협력을 고려하지 않고 객체를 고립시킨다.

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.   
- 데이터는 구현을 해나가면서 정의되는 부분이다. 빠르게 결정되면 데이터 위주의 행동을 고려하기 때문에 캡슐화가 점차 무너진다.         

### 데이터 중심 설계는 객체를 고립시킨채 행동을 정의한다.
- 올바른 객체지향 설계는 객체 내부가 아닌 외부에 맞춰져 있다. 어떤 상태를 가지고 어떻게 관리하는지는
그 객체만 알뿐 외부에선 메시지를 통해 협력을 하면 된다.
- 데이터 중심 설계는 외부가 아닌 내부에 초점이 맞춰지게 되므로 협력을 억지로 끼워맞추다보니 캡슐화가 무너진다.

# 결론
- 캡슐화를 잘하자.
- 높은 응집도와 낮은 결합도를 가지도록 하자.
- 객체 설계시 데이터가 아닌 책임, 행동에 초점을 맞춰 구현하자.