## **협력**

객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용

메시지 전송 : 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단

메시지를 수신한 객체는 **메서드**를 시행해 요청에 응답한다.

외부의 객체는 오직 메시지만 전송할 수 있고, 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.

 - 객체는 자신의 일을 스스로 처리할 수 있는 자율적인 존재

객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 **캡슐화**하는 것이다. 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.

상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다. 따라서 협력은 객체를 설계하는 데 필요한 일종의 **문맥(context)** 을 제공한다.



## **책임**

객체가 협력에 참여하기 위해 수행하는 행동

객체의 책임을 크게 **하는 것**과 **아는 것**의 두 가지 범주로 나누어 세분화하고 있다.

하는 것

 - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것

 - 다른 객체의 행동을 시작시키는 것

 - 다른 객체의 활동을 제어하고 조절하는 것

아는 것

 - 사적인 정보에 관해 아는 것

 - 관련된 객체에 관해 아는 것

 - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

정보 전문가 패턴 : 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것



## **책임 주도 설계(RDD)**

 - 책임을 찾고 책임을 수행한 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법

 - 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있게 함



## **메시지가 객체를 결정**

객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택

 - 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택

메시지가 객체를 선택해야하는 이유

1. 객체가 **최소한의 인터페이스**를 가질 수 있게 된다.

 - 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있다.

2. 객체는 충분히 **추상적인 인터페이스**를 가질 수 있게 된다.

 - 객체의 인터페이스는 무엇을 하는지는 표현해야 하지만 어떻게 수행하는지를 노출해서는 안 된다.



## **행동이 상태를 결정**

객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동

 - 객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다.



## **역할**

객체가 어떤 특정한 협력 안에서 수행하는 책임들의 집합

역할을 구현하는 가장 일반적인 방법은 **추상 클래스**와 **인터페이스**를 사용하는 것
