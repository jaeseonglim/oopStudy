## **DRY 원칙**

모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다

중복 여부를 판단하는 기준은 변경

 - 요구사항이 변경 됐을 때 두 코드를 함께 수정해야 한다면 중복이다



## **상속을 이용해서 중복 코드 제거하기**

이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용해라

상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각처럼 쉽지 않다

부모 클래스와 자식 클래스 사이의 결합도를 높인다



## **취약한 기반 클래스 문제**

부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상

자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다

자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화 시킨다



## **불필요한 인터페이스 상속 문제**

자바의 초기 버전에서 상속을 잘 못 사용한 대표적인 예 : Stack과 Vector, Properties와 HashTable 



## **메서드 오버라이딩의 오작용 문제**

InstrumentedHashSet과 HashSet addAll 메서드

클래스가 상속 되기를 원한다면 상속을 위해 클래스를 설계하고 문서화해야 하며, 그렇지 않으면 상속을 금지시켜야 한다 - By. Joshua Bloch



## **부모 클래스와 자식 클래스의 동시 수정 문제**

부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요한다

부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 함께 수정해야 하는 상황 역시 빈번하게 발생한다



## **상속을 위한 경고**

1. 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합 된다

 - super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라

2. 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다

3. 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다

4. 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경해야 한다



## **차이에 의한 프로그래밍**

추상화에 의존하자

 - 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만들자

차이를 메서드로 추출하라

 - 중복 코드 안에서 차이점을 별도의 메서드로 추출하라

중복 코드를 부모 클래스로 올려라

 - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라
